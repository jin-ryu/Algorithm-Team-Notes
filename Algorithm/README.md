# Python Algorithm

💁 **유찌니의 알고리즘 노트**

- [그리디](#그리디)
- [구현](#구현)
- [DFS&BFS](#DFS&BFS)
  - [스택 자료구조](#스택-자료구조)
  - [큐 자료구조](#큐-자료구조)
  - [재귀 함수](#재귀-함수)
  - [DFS (Depth First Search)](#DFS- (Depth-First-Search))
  - [BFS (Breadth First Search)](#BFS-(Breadth-First-Search))
- [정렬 알고리즘](#정렬-알고리즘)
  - [선택 정렬](#t선택-정렬)
  - [삽입 정렬](#삽입-정렬)
  - [퀵 정렬](#퀵-정렬)
  - [계수 정렬](#계수-정렬)
  - [정렬 알고리즘 비교하기](#정렬-알고리즘-비교하기)
- [이진 탐색](#이진-탐색)
  - [파이썬 이진 탐색 라이브러리](#파이썬-이진-탐색-라이브러리)
  - [파라메트릭 서치 (Parametric Search)](#파라메트릭-서치-(Parametric-Serach))
- [다이나믹 프로그래밍](#다이나믹-프로그래밍)
  - [피보나치 수열](#피보나치-수열)
  - [메모이제이션 (Memoization)](#메모이제이션-(Memoization))
  - [탑다운 VS 보텀업](#탑다운-VS-보텀업)
  - [다이나믹 프로그래밍 VS 분할 정복](#다이나믹-프로그래밍-VS-분할-정복)
  - [다이나믹 프로그래밍 문제에 접근하는 방법](#다이나믹-프로그래밍-문제에-접근하는-방법)
- [최단 경로 알고리즘](#최단-경로-알고리즘)
  - [다익스트라 알고리즘](#다익스트라-알고리즘)
  - [플로이드 워셜 알고리즘](#플로이드-워셜-알고리즘)
- [기타 그래프 이론](#기타-그래프-이론)
  - [서로소 집합](#서로소-집합)
  - [최소 신장 트리](#최소-신장-트리)
  - [크루스칼 알고리즘](#크루스칼-알고리즘)
  - [위상 정렬](#위상-정렬)
- [기타 빈출 알고리즘](#기타-빈출-알고리즘)
  - [소수 판별 알고리즘](#소수-판별-알고리즘)
  - [에라토스테네스의 체](#에라토스테네스의-체)
  - [투 포인터](#투-포인터)
  - [구간 합 빠르게 계산하기](#구간-합-빠르게-계산하기)



## 알고리즘 설계 Tip

- 일반적으로 CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우
  - C언어를 기준으로 통상 1~3초 가량의 시간이 소요
  - Python을 기준으로 통상 5~15초 가량의 시간이 소요
    - Pypy의 경우 때때로 C언어보다도 빠르게 동작하기도 함
- O(N<sup>3</sup>)의 알고리즘을 설계한 경우, N의 값이 5,000이 넘는다면 얼마나 걸릴까요?
- **코딩 테스트 문제에서 시간 제한은 통상 1~5초 가량**이라는 점을 유의
  - 혹여 문제에 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는 것이 합리적



## 그리디

#### 그리디 알고리즘(탐욕법)

- **현재 상황에서 지금 당장 좋은 것만 고르는 방법**
- 일반적으로 문제를 풀기  위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
- 그리디 해법은 그 정당성 분석이 중요
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많음
- 하지만 코딩 테스트에서의 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적이 되는 상황에서, 이를 추론**할 수 있어야 풀리도록 출제



## 구현

#### 구현(Implementation) <small> 시뮬레이션과 완전 탐색</small>

- **머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정**

- 구현 유형의 문제 =  **풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제**

- 구현 유형의 예시

  - 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제 <small><파이썬 강점> </small>
  - 적절한 라이브러리를 찾아서 사용해야 하는 문제 <small> ex) 순열과 조합 </small>

- 일반적으로 알고리즘 문제에서의 2차원 공간은 **행렬(Matrix)**의 의미

  - x, y의 2차원 좌표계와는 달리 왼쪽 위에서 (0,0)이 시작

- 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 **방향 백터**가 자주 활용

  ```python
  # 동, 북, 서, 남
  dx = [0, -1, 0, 1]	# 행(가로)
  dy = [1, 0, -1, 0]	# 열(세로)
  
  # 현재 위치
  x, y = 2, 2
  
  for i in range(4):
      # 다음 위치
      nx = x + dx[i]
      ny = y + dy[i]
      print(nx, ny)
  ```



## DFS&BFS

#### 그래프 탐색 알고리즘: DFS/BFS

- 탐색(Search)이란 많은 양의 데이터 중에서 **원하는 데이터를 찾는 과정**
- 대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있음
- **DFS/BFS는 코딩 테스트에서 매우 자주 등장하는 유형**이므로 반드시 숙지

#### 스택 자료구조

- 먼저 들어 온 데이터가 나중에 나가는 형식(선입후출)의 자료구조

- **입구와 출구가 동일한 형태**로 스택을 시각화할 수 있음

  - 박스 쌓기 예시

- **스택 구현 예제 (Python)**

  ```python
  stack = [] 
  
  # 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
  stack.append(5)
  stack.append(2)
  stack.append(3)
  stack.append(7)
  stack.pop()
  stack.append(1)
  stack.append(4)
  stack.pop()
  
  print(stack[::-1])	# 최상단 원소(top)부터 출력	[1, 3, 2, 5]
  print(stack)		# 최하단 원소부터 출력	[5, 2, 3, 1]
  ```


#### 큐 자료구조

- 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)의 자료구조
- 큐는 **입구와 출구가 모두 뚫려 있는 터널**과 같은 형태로 시각화 할 수 있음

- **큐 구현 예제 (Python)**

  ```python
  from collections import deque
  
  # 큐(Queue) 구현을 위해 deque 라이브러리 사용 (시간적 우수)
  queue = deque()
  
  # 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
  # 오른쪽에서 들어와서 왼쪽으로 나가는 반대 구조
  queue.append(5)
  queue.append(2)
  queue.append(3)
  queue.append(7)
  queue.popleft()
  queue.append(1)
  queue.append(4)
  queue.popleft()
  
  print(queue)	# 먼저 들어온 순서대로 출력 	deque([3, 7, 1, 4])
  queue.reverse()	# 역순으로 바꾸기
  print(queue)	# 나중에 들어온 원소부터 출력 	deque([4, 1, 7, 3])
  ```


#### 재귀 함수

- 재귀 함수(Recursive Function)란 **자기 자신을 다시 호출**하는 함수

- 단순한 형태의 재귀 함수 예제

  - '재귀 함수를 호출합니다.' 라는 문자열을 무한히 출력
  - 어느정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력

  ```python
  def recursive_function():
      print('재귀 함수를  호출합니다.')
      recursive_function()
      
  recursive_function()
  ```

- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 함

- 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있음

  ```python
  def recursive_function():
      # 100번째 호출을 했을 때 종료되도록 종료 조건 명시
      if i == 100:
          return
      print(i, '번째 재귀함수에서', i+1, '번째 재귀함수를 호출합니다.')
      recursive_function(i+1)
      print(i, '번째 재귀함수를 종료합니다.')
      
  recursive_function()
  ```

- **팩토리얼 구현 예제**

  - n! = 1 x 2 x 3 x ... x (n-1) x n
  - 수학적으로 0!과 1!의 값은 1임

  ```python
  # 반복적으로 구현한 n!
  def factorial_iterative(n):        
      result = 1
      # 1부터 n까지의 수를 차례대로 곱하기
      for i in range(1, n + 1):
         result *= i
      return result
  
  # 재귀적으로 구현한 n!
  def factorial_recursive(n):        
      if n <= 1: # n이 1 이하인 경우 1을 반환
          return 1
      # n! = n * (n - 1)!를 그대로 코드로 작성하기
      return n * factorial_recursive(n - 1)
  
  # 각각의 방식으로 구현한 n! 출력(n = 5)
  print('반복적으로 구현:', factorial_iterative(5))
  print('재귀적으로 구현:', factorial_recursive(5))
  ```

- 최대공약수 계산(유클리드 호제법) 예제

  - <u>두 개의 자연수에 대한 최대공약수</u>를 구하는 대표적인 알고리즘

  - **유클리드 호제법**

    - 두 자연수 A, B에 대하여 (A > B) A를 B로 나눈 나머지를 R이라고 합시다.
    - 이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같습니다.

    ```python
    def gcd(a, b):
        if a % b == 0:
            return b
        else:
            return gcd(b, a % b)
        
    print(gcd(192, 162))
    ```

  - 유클리드 호제법의 아이디어를 그대로 재귀 함수로 작성할 수 있음

    - **예시**: GCD(192, 162)

      | 단계 |  A   |  B   |
      | :--: | :--: | :--: |
      |  1   | 192  | 162  |
      |  2   | 162  |  30  |
      |  3   |  30  |  12  |
      |  4   |  12  |  6   |

- **재귀 함수 사용의 유의 사항**

  - 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있음
    - 단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있으므로 신중하게 사용
  - 모든 <u>재귀 함수는 반복문을 이용하여 동일한 기능을 구현</u>할 수 있음
  - 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있음
  - 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓임
    - 그래서 스택을 사용해야할 때 구현상 **스택 라이브러리 대신에 재귀 함수를 이용**하는 경우가 많음

#### DFS (Depth First Search)

- DFS는 **깊이 우선 탐색**이라고 부르며 그래프에서 **깊은 부분을 우선적으로 탐색하는 알고리즘**
- DFS는 **스택 자료구조(혹은 재귀함수)를 이용**하며, 구체적인 동작 과정은 다음과 같음
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 합니다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.

<img src="https://user-images.githubusercontent.com/45402031/96075853-ee681e80-0ee6-11eb-9602-3bf16cfbe937.png" alt="image-20201015001153248" style="zoom:67%;" />

- **DFS 소스코드 예제 (Python)**

  ```python
  # DFS 메서드 정의
  def dfs(graph, v, visited):
      # 현재 노드를 방문 처리
      visited[v] =  True
      print(v, end = ' ')
      # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
      for i in graph[v]:
          if not visited[i]:
              dfs(graph, i, visited)	
  
  # 각 노드가 연결된 정보를 표현 (2차원 리스트)
  graph = [
      [],
      [2, 3, 8],
      [1, 7],
      [1, 4, 5],
      [3, 5],
      [3, 4],
      [7],
      [2, 6, 8],
      [1, 7]
  ]
  
  # 각 노드가 방문된 정보를 표현 (1차원 리스트)
  visited = [False] * 9
  
  # 정의된 DFS 함수 호출
  dfs(graph, 1, visited)
  ```
  

#### BFS (Breadth First Search)

- BFS는 **너비 우선 탐색**이라고도 부르며, 그래프에서 **가까운 노드부터 우선적으로 탐색하는 알고리즘**

- BFS는 **큐 자료구조**를 이용하며, 구체적인 동작 과정은 다음과 같습니다.
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리합니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.  

- 특정 조건에서의 **최단경로 문제**를 해결하기 위해 효과적으로 사용될 수 있음

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201015002844846.png" alt="image-20201015002844846" style="zoom:67%;" />



- **BFS 소스코드 예제 (Python)**

  ```python
  from collections import deque
  
  # BFS 메서드 정의
  def bfs(graph, start, visited):
      # 큐(Queue) 구현을 위해 deque 라이브러리 사용
      queue = deque([start])
      # 현재 노드를 방문 처리
      visited[start] = True
      # 큐가 빌 때까지 반복
      while queue:
          # 큐에서 하나의 원소를 뽑아 출력하기
          v =  queue.popleft()
          print(v, end = ' ')
          # 아직 방문하지 않은 인접한 원소들을 큐에 삽입
          for i in graph[v]:
              if not visited[i]:
                  queue.append(i)
                  visited[i] = True
                  
  # 각 노드가 연결된 정보를 표현 (2차원 리스트)
  graph = [
      [],
      [2, 3, 8],
      [1, 7],
      [1, 4, 5],
      [3, 5],
      [3, 4],
      [7],
      [2, 6, 8],
      [1, 7]
  ]
  
  # 각 노드가 방문된 정보를 표현 (1차원 리스트)
  visited = [False] * 9
  
  # 정의된 BFS 함수 호출
  bfs(graph, 1, visited)  
  ```




## 정렬 알고리즘

- 정렬 알고리즘
  - **정렬(Sorting)**이란 <u>데이터를 특정한 기준에 따라 순서대로 나열</u>하는 것을 말합니다.
  - 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.
  
- **정렬 라이브러리 키(Key) 기준 정렬 예제**

  ```python
  array = [('바나나', 2), ('사과', 5), ('당근', 3)]
  
  # 1. Key 함수 정의
  def setting(data):
      return data[1]
  result = sorted(array, key=setting)
  
  # 2. lambda 함수 이용
  result = sorted(array, key=lambda x:x[1])
  
  print(result)
  ```

#### 선택 정렬

- 처리되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복**합니다.

- **예시**: 7 5 9 0 3 1 6 2 4 8

  - [Step 0] 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꿉니다.
    - **0** 5 9 **7** 3 1 6 2 4 8
  - [Step 1] 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꿉니다.
    - 0 **1** 9 7 3 **5** 6 2 4 8
  - [Step 2] 처리되지 않은 데이터 중 가장 작은 '2'을 선택해 가장 앞의 '9'와 바꿉니다.
    - 0 1 **2** 7 3 5 6 **9** 4 8
  - [Step 3] 처리되지 않은 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꿉니다.
    - 0 1 2 **3 7** 5 6 9 4 8
  - 이러한 과정을 반복하면 다음과 같이 정렬이 완료됩니다.

- **선택 정렬 소스코드 (Python)**

  ```python
  array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
  
  for i in range(len(array)):
      min_index = i # 가장 작은 원소의 인덱스
      for j in range(i + 1, len(array)):
          if array[min_index] > array[j]:
              min_index = j
      array[i], array[min_index] = array[min_index], array[i] # 스와프
  
  print(array)
  ```

- **선택 정렬의 시간 복잡도**

  - 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.

  - 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다.
    $$
    N + (N-1) + (N-2) + ... + 2
    $$

  - 이는 (N<sup>2</sup> + N - 2) / 2 로 표현할 수 있는데, 빅오 표기법에 따라서 **O(N<sup>2</sup>)**이라고 작성합니다. 

#### 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입**합니다.

- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.

- **예시**: 7 5 9 0 3 1 6 2 4 8

  - [Step 0] 첫 번째 데이터 '7'은 그 자체로 정렬되어 있다고 판단하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단합니다. '7'의 완쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재합니다.
    - **5** 7 9 0 3 1 6 2 4 8
  - [Step 1] 이어서 '9'가 어떤 위치로 들어갈지 판단합니다.
    - 5 7 **9** 0 3 1 6 2 4 8
  - [Step 2] 이어서 '0이 어떤 위치로 들어갈지 판단합니다.
    - **0** 5 7 9 3 1 6 2 4 8
  - [Step 3] 이어서 '3이 어떤 위치로 들어갈지 판단합니다.
    - 0  **3** 5 7 9 1 6 2 4 8
  - 이러한 과정을 반복하면 다음과 같이 정렬이 완료됩니다.

- **삽입 정렬 소스코드 (Python)**

  ```python
  array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
  
  for i in range(1, len(array)):
      for j in range(i, 0, -1): # 인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
          if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
              array[j], array[j - 1] = array[j - 1], array[j]
          else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
              break
  
  print(array)
  ```

- **삽입 정렬의 시간 복잡도**
  - 삽입 정렬의 시간 복잡도는 **O(N<sup>2</sup>)**이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.
  - 삽입 정렬은 <u>현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작</u>합니다.
    - 최선의 경우 **O(N)**의 시간 복잡도를 가집니다.
    - 이미 정렬되어 있는 상태에서 다시 삽입 정렬을 수행하면 어떻게 될까요?
      - 어디를 들어가질 고민하는 부분이 상수 시간으로 작동함

#### 퀵 정렬

- <u>기준 데이터를 설정</u>하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**입니다.

- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.

- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.

- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정합니다.

- **예시**: 5 7 9 0 3 1 6 2 4 8

  - [Step 0] 현재 피벗의 값은 '5'입니다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택됩니다. 이제 두 데이터의 위치를 서로 변경합니다. 
    - 5 **7** 9 0 3 1 6 2 **4** 8
  - [Step 1] 현재 피벗의 값은 '5'입니다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '9'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'가 선택됩니다. 이제 두 데이터의 위치를 서로 변경합니다. 
    - 5 4 **9** 0 3 1 6 **2** 7 8
  - [Step 2] 현재 피벗의 값은 '5'입니다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '1'이 선택됩니다.  **단, 이처럼 위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경합니다.**
    -  <u>5</u> 4 2 0 3 **1** **6** 9 7 8
  - [분할 완료] 이제 '5'의 왼쪽에 있는 데이터는 모두 '5'보다 작고, 오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있습니다. 이렇게 <u>피벗을 기준으로 데이터 묶음을 나누는 작업</u>을 **분할(Divide)**이라고 합니다.
    -  <u>1 4 2 0 3</u> 5 <u>6 9 7 8</u>
  - [왼쪽 데이터 묶음 정렬] 왼쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행합니다.

  - [오른쪽 데이터 묶음 정렬] 오른쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행합니다.
    - 이러한 과정을 반복하면 전체 데이터에 대해서 정렬이 수행됩니다.

- **퀵 정렬이 빠른 이유: 직관적인 이해**

  - 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)를 기대할 수 있습니다.
    - 너비 x 높이 = N x logN = NlogN <small>(밑이 2인 logN)</small>

- **퀵 정렬의 시간 복잡도**

  - 퀵 정렬은 평균의 경우 **O(NlogN)**의 시간 복잡도를 가집니다.
  - 하지만 최악의 경우 **O(N<sup>2</sup>)**의 시간 복잡도를 가집니다.
    - <u>첫 번째 원소를 피벗으로 삼을 때,</u> 이미 정렬된 배열에 대해서 퀵 정렬을 수행하면 어떻게 될까요?
    - 0 1 2 3 4 5 6 7 8 9의 경우 매번 왼쪽 분할은 비어있고, 오른쪽 분할이 나머지 원소들을 가지고 있으므로 이는 선형탐색과 같음
    - 표준 라이브러리를 이용할 때는 O(NlogN)을 항상 보장하는 형태로 구현되어 있다.

- **귁 정렬 소스코드: 일반적인 방식 (Python)**

  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
  
  def quick_sort(array, start, end):
      if start >= end: # 원소가 1개인 경우 종료
          return
      pivot = start # 피벗은 첫 번째 원소
      left = start + 1
      right = end
      while(left <= right):
          # 피벗보다 큰 데이터를 찾을 때까지 반복 
          while(left <= end and array[left] <= array[pivot]):
              left += 1
          # 피벗보다 작은 데이터를 찾을 때까지 반복
          while(right > start and array[right] >= array[pivot]):
              right -= 1
          if(left > right): # 엇갈렸다면 작은 데이터와 피벗을 교체
              array[right], array[pivot] = array[pivot], array[right]
          else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
              array[left], array[right] = array[right], array[left]
      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
      quick_sort(array, start, right - 1)
      quick_sort(array, right + 1, end)
  
  quick_sort(array, 0, len(array) - 1)
  print(array)
  ```

- **퀵 정렬 소스코드: 파이썬의 장점을 살린 방식**

  - List slicing과 comprehension 활용

  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
  
  def quick_sort(array):
      # 리스트가 하나 이하의 원소만을 담고 있다면 종료
      if len(array) <= 1:
          return array
  
      pivot = array[0] # 피벗은 첫 번째 원소
      tail = array[1:] # 피벗을 제외한 리스트
  
      left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
      right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분
  
      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
      return quick_sort(left_side) + [pivot] + quick_sort(right_side)
  
  print(quick_sort(array))
  ```

#### 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작**하는 정렬 알고리즘입니다.
  
- 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때** 사용 가능합니다.
  
- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 **O(N+K)**를 보장합니다.

- **예시**: 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

  - [Step 0] 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성합니다. <small>(이 때문에 상대적으로 공간복잡도가 높음)</small>

    - 첫번째 줄은 인덱스, 두번째 줄은 개수(Count)를 의미

    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
    | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
    |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |

  - [Step 1] 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킵니다.

    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
    | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
    |  2   |  2   |  2   |  1   |  1   |  2   |  1   |  1   |  1   |  2   |

  - 결과를 확인할 때는 리스트의 첫번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력합니다.

    - 출력 결과: 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9

- **계수 정렬 소스코드 (Python)**

  ```python
  # 모든 원소의 값이 0보다 크거나 같다고 가정
  array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
  # 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)
  count = [0] * (max(array) + 1)
  
  for i in range(len(array)):
      count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가
  
  for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
      for j in range(count[i]):
          print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
  ```

- **계수 정렬의 복잡도 분석**
  - 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 **O(N+K)**입니다.
  - 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있습니다.
    - 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해 봅시다.
  - 계수 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때** 효과적으로 사용할 수 있습니다.
    - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬에 효과적입니다.

#### 정렬 알고리즘 비교하기

- 앞서 다룬 네 가지 정렬 알고리즘을 비교하면 다음과 같습니다.
- 추가적으로 대부분의 프로그래밍 언어에서 지원하는 <u>표준 정렬 라이브러리는 최악의 경우에도 **O(NlogN)**을 보장</u>하도록 설계되어 있습니다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| :-----------: | :--------------: | :---------: | ------------------------------------------------------------ |
| **선택 정렬** | O(N<sup>2</sup>) |    O(N)     | 아이디어가 간단합니다.                                       |
| **삽입 정렬** | O(N<sup>2</sup>) |    O(N)     | 데이터가 가의 정렬되어 있을 때는 가장 빠릅니다.              |
|  **퀵 정렬**  |     O(NlogN)     |    O(N)     | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.              |
| **계수 정렬** |      O(N+K)      |   O(N+K)    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다. |



## 이진 탐색

- **이진 탐색 알고리즘**
  - 순차 탐색: 리스트 안에 있는 특정한 **데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인**하는 방법
  - 이진 탐색: <u>정렬되어 있는 리스트</u>에서 **탐색 범위를 절반씩 좁혀가며 데이터를 탐색**하는 방법
    - 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정합니다.
- **이진 탐색 동작 예시**
  - 이미 정렬된 10개의 데이터 중에서 값이 4인 원소를 찾는 예시를 살펴봅시다.
    - 0 2 **4** 6 8 10 12 14 16 18
    - [Step 1] 시작점: 0, 끝점: 9, 중간점: 4 (소수점 이하 제거)
      -  <u>0</u> 2 **4** 6 <u>8</u> 10 12 14 16 <u>18</u> 
    - [Step 2] 시작점: 0, 끝점: 3, 중간점: 1 (소수점 이하 제거)
      -  <u>0</u> <u>2</u> **4** <u>6</u>  (중간점이 '4'보다 크므로, 오른쪽은 고려할 필요 없음)
    - [Step 3] 시작점: 2, 끝점: 3, 중간점: 2 (소수점 이하 제거)
      - **<u>4</u>**, <u>6</u> (중간점이 '4'보다 작으므로, 왼쪽은 고려할 필요 없음)
- **이진 탐색의 시간 복잡도**
  - 단계마다 탐색 범위를 2로 나누는 것과 동일하므로 **연산 횟수는 log<sub>2</sub>N에 비례**합니다.
  - 예를 들어, 초기 데이터 개수가 32개일 때, 이상적으로 1단계를 거치면 16개가량의 데이터만 남습니다.
    - 2단계를 거치면 8개가량의 데이터만 남습니다.
    - 3단계를 거치면 4개가량의 데이터만 남습니다.
  - 다시 말해 이진 탐색은 탐색 범위를 절반씩 줄이며, 시간 복잡도는 **O(logN)**을 보장합니다.

- **이진 탐색 소스코드: 재귀적 구현 (Python)**

  ```python
  # 이진 탐색 소스코드 구현 (재귀 함수)
  def binary_search(array, target, start, end):
      if start > end:
          return None
      mid = (start + end) // 2
      # 찾은 경우 중간점 인덱스 반환
      if array[mid] == target:
          return mid
      # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
      elif array[mid] > target:
          return binary_search(array, target, start, mid - 1)
      # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
      else:
          return binary_search(array, target, mid + 1, end)
  
  # n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
  n, target = list(map(int, input().split()))
  # 전체 원소 입력 받기
  array = list(map(int, input().split()))
  
  # 이진 탐색 수행 결과 출력
  result = binary_search(array, target, 0, n - 1)
  if result == None:
      print("원소가 존재하지 않습니다.")
  else:
      print(result + 1)
  ```

- **이진 탐색 소스코드: 반복문 구현 (Python)**

  ```python
  # 이진 탐색 소스코드 구현 (반복문)
  def binary_search(array, target, start, end):
      while start <= end:
          mid = (start + end) // 2
          # 찾은 경우 중간점 인덱스 반환
          if array[mid] == target:
              return mid
          # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
          elif array[mid] > target:
              end = mid - 1
          # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
          else:
              start = mid + 1
      return None
  
  # n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
  n, target = list(map(int, input().split()))
  # 전체 원소 입력 받기
  array = list(map(int, input().split()))
  
  # 이진 탐색 수행 결과 출력
  result = binary_search(array, target, 0, n - 1)
  if result == None:
      print("원소가 존재하지 않습니다.")
  else:
      print(result + 1)
  ```

#### 파이썬 이진 탐색 라이브러리

- bisect_left(a, x): 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스를 반환

- bisect_right(a, x): 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스를 반환

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201016140702045.png" alt="image-20201016140702045" style="zoom:67%;" />

- **값이 특정 범위에 속하는 데이터 개수 구하기**

  ```python
  from bisect import bisect_left, bisect_right
  
  # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
  def count_by_range(a, left_value, right_value):
      right_index = bisect_right(a, right_value)
      left_index = bisect_left(a, left_value)
      return right_index - left_index
  
  # 배열 선언
  a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]
  
  # 값이 4인 데이터 개수 출력
  print(count_by_range(a, 4, 4))
  
  # 값이 [-1, 3]의 범위에 있는 데이터 개수 출력
  print(count_by_range(a, -1, 3))
  ```

#### 파라메트릭 서치 (Parametric Search)

- **파라메트릭 서치**란 <u>최적화 문제를 결정문제('예' 혹은 '아니오')로 바꾸어 해결하는 기법</u>입니다.
  - 최적화 문제: 어떤 함수의 값을 최대한 높이거나 낮추는 문제
  - 예시: 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제
- 일반적으로 코딩 테스트에서 파라메트릭 서치 문제는 **이진 탐색을 이용하여 해결**할 수 있습니다.



## 다이나믹 프로그래밍

- 다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**입니다.
- <u>이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장</u>하여 다시 계산하지 않도록 합니다.
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운과 보텀업)으로 구성됩니다.

- 다이나믹 프로그래밍은 **동적 계획법**이라고도 부릅니다.
- 일반적인 프로그래밍 분야에서 동적(Dynamic)이란 어떤 의미를 가질까요?
  - 자료구조에서 동적 할당(Dynamic Allocation)은 '**프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**'을 의미합니다.
  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 **별다른 의미 없이 사용된 단어**입니다.

- **다이나믹 프로그래밍의 조건**

  - 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.

  1. **최적 부분 구조 (Optimal Substructure)**
     - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
  2. **중복되는 부분 문제 (Overlapping Subproblem)**
     - 동일한 작은 문제를 반복적으로 해결해야 합니다.

#### 피보나치 수열

- 피보나치 수열은 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산할 수 있습니다.
  $$
  1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  $$
  
- **점화식**이란 <u>인접한 항들 사이의 관계식</u>을 의미합니다. 

- 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.
  $$
  a_{n} = a_{n-1} + a_{n-2}, a_{1} = 1, a_{2} = 1
  $$

- 프로그래밍에서는 이러한 수열을 배열이나 리스트를 이용해 표현합니다.

- **피보나치 수열: 단순 재귀 코드(Python)** <small> 비효율적</small>

  ```python
  # 피보나치 함수(Fibonacci Function)을 재귀함수로 구현
  def fibo(x):
      if x == 1 or x == 2:
          return 1
      return fibo(x - 1) + fibo(x - 2)
  
  print(fibo(4))
  ```

- **피보나치 수열의 시간 복잡도 분석**

  - 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.
  - 다음과 같이 f(2)가 <u>여러 번 호출</u>되는 것을 확인할 수 있습니다. (**중복되는 부분 문제**)

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019202843158.png" alt="image-20201019202843158" style="zoom:67%;" />

- **피보나치 수열의 시간 복잡도 분석**

  - 피보나치 수열의 시간 복잡도는 다음과 같습니다.
    - 세타 표기법: θ(1.618...<sup>N</sup>)
    - 빅오 표기법: O(2<sup>N</sup>)
  - 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야 합니다.
  - 그렇다면 f(100)을 계산하기 위해 얼마나 많은 연산을 수행해야 할까요?

- **피보나치 수열의 효율적인 해법: 다이나믹 프로그래밍**
  - 다이나믹 프로그래밍의 사용 **조건**을 만족하는지 확인합니다.
    1. **최적 부분 구조**: 큰 문제를 작은 문제로 나눌 수 있습니다.
    2. **중복되는 부분 문제:** 동일한 작은 문제를 반복적으로 해결합니다.
  - 피보나치 수열은 다이나믹 프로그래밍 사용 조건을 만족합니다.

#### 메모이제이션 (Memoization)

- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
- <u>한 번 계산한 결과를 메모리 공간에 메모</u>하는 기법입니다.
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
  - 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 합니다.

#### 탑다운 VS 보텀업

- 탑다운(메모이제이션) 방식은 **하향식**이라고도 하며 보텀업 방식은 **상향식**이라고도 합니다.
  - **탑다운(메모이제이션):** 재귀함수 형태로 구현
  - **보텀업**: 반복문으로 구현
- 다이나믹 프로그래밍의 전형적인 형태는 **보텀업** 방식입니다.
  
  - 결과 저장용 리스트(배열)는 **DP 테이블**이라고 부릅니다.
- 엄밀히 말하면 메모이제이션은 <u>이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미</u>합니다.
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다. 
    (엄밀히 말하면 서로 다른 개념)
  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.

- **피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드(Python)**

  ```python
  # 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
  d = [0] * 100
  
  # 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
  def fibo(x):
      # 종료 조건(1 혹은 2일 때 1을 반환)
      if x == 1 or x == 2:
          return 1
      # 이미 계산한 적 있는 문제라면 그대로 반환
      if d[x] != 0:
          return d[x]
      # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
      d[x] = fibo(x - 1) + fibo(x - 2)
      return d[x]
  
  print(fibo(99))
  ```

- **피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드(Python)**

  ```python
  # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
  d = [0] * 100
  
  # 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
  d[1] = 1
  d[2] = 1
  n = 99
  
  # 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
  for i in range(3, n + 1):
      d[i] = d[i - 1] + d[i - 2]
  
  print(d[n])
  ```

- **피보나치 수열: 메모이제이션 동작 분석**
  - 이미 계산된 결과를 메모리에 저장하면 다음과 같이 색칠된 노드만 처리할 것을 기대할 수 있습니다.
    
    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019212832088.png" alt="image-20201019212832088" style="zoom:67%;" />
    
  -  메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 **O(N)**입니다.

#### 다이나믹 프로그래밍 VS 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있습니다.

  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황

- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**입니다.

  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
  - 분할 정복 문제에서는 동일한 부분 문제과 반복적으로 계산되지 않습니다.

- **분할 정복**의 대표적인 예시인 퀵 정렬을 살펴봅시다.

  - 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않습니다.
  - 분할 이후 해당 피벗을 다시 처리해야하는 부분 문제를 호출하지 않습니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019213342546.png" alt="image-20201019213342546" style="zoom:67%;" />

#### 다이나믹 프로그래밍 문제에 접근하는 방법

- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요합니다.
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있습니다.
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해 봅시다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있습니다.
- <u>일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제</u>되는 경우가 많습니다.



## 최단 경로 알고리즘

- **최단 경로 문제**
  - 최단 경로 알고리즘은 **가장 짧은 경로를 찾는 알고리즘**을 의미합니다.
  - **다양한 문제 상황**
    - 한 지점에서 다른 한 지점까지의 최단 경로
    - 한 지점에서 다른 모든 지점까지의 최단 경로
    - 모든 지점에서 다른 모든 지점까지의 최단 경로
  - 각 지점은 그래프에서 **노드**로 표현
  - 지점 간 연결된 도로는 그래프에서 **간선**으로 표현

<img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020015518056.png" alt="image-20201020015518056" style="zoom: 67%;" />

#### 다익스트라 알고리즘

- **다익스트라 최단 경로 알고리즘 개요**

  - **특정한 노드**에서 출발하여 **다른 모든 노드**로 가는 최단 경로를 계산합니다.
  - 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작합니다.
    - 현실 세계의 도로(간선)은 음의 간선으로 표현되지 않습니다.
  - 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류됩니다.
    - **매 상황에서 가장 비용이 적은 노드를 선택**해 임의의 과정을 반복합니다.
    - 길찾기 문제 자체는 다이나믹 프로그래밍의 원리가 적용되어 있다고 볼 수 있음
      - 최선 = 현재 노드까지 최선 + 현재 노드에서 다음 노드까지의 최선 

- **다익스트라 최단 경로 알고리즘**

  - 알고리즘의 **동작 과정**은 다음과 같습니다.
    1. 출발 노드를 설정합니다.
    2. 최단 거리 테이블을 초기화합니다.
    3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
    4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계싼하여 최단 거리 테이블을 갱신합니다.
    5. 위 과정에서 3번과 4번을 반복합니다.
  - 알고리즘 동작 과정에서 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가지고 있습니다.
  - 처리 과정에서 더 짧은 경로를 찾으면 '이제부터는 이 경로가 제일 짧은 경로야'라고 갱신합니다.

- **다익스트라 알고리즘: 동작 과정 살펴보기**

  - **[초기 상태]** 그래프를 준비하고 출발 노드를 설정합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020020727476.png" alt="image-20201020020727476" style="zoom:67%;" />

  - **[Step 1]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **1번** 노드를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020020850941.png" alt="image-20201020020850941" style="zoom:67%;" />

  - **[Step 2]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **4번** 노드를 처리합니다.
  - <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020021026823.png" alt="image-20201020021026823" style="zoom:67%;" />

  - **[Step 3]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **2번** 노드를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020021235863.png" alt="image-20201020021235863" style="zoom:67%;" />

    - 일반적으로 최단 거리가 같을 때는 앞에 있는 노드를 우선적으로 선택
    - 이미 방문처리가 된 노드를 무시하게 구현해도 됨
      - 방문처리가 된 노드는 최단 거리가 이미 결정된 노드이기 때문

  - **[Step 4]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **5번** 노드를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020021511595.png" alt="image-20201020021511595" style="zoom:67%;" />

  - **[Step 5]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **3번** 노드를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020021646376.png" alt="image-20201020021646376" style="zoom:67%;" />

  - **[Step 6]** 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 **6번** 노드를 처리합니다.

  - <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020021721219.png" alt="image-20201020021721219" style="zoom:67%;" />

    - 다른 노드까지의 최단거리는 더 이상 바뀌지 않기 때문에, 마지막 노드는 처리하지 않아**도 결과가 동일**

- **다익스트라 알고리즘의 특징**

  - 그리디 알고리즘: **매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택**해 임의의 과정을 반복합니다.
  - 단계를 거치며 **한 번 처리된 노드의 최단 거리는 고정**되어 더 이상 바뀌지 않습니다.
    - **한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해**할 수 있습니다.
  - 다익스트라 알고리즘을 수행한 뒤에 <u>테이블에 각 노드까지의 최단 거리 정보가 저장</u>됩니다.
    -  완벽한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능을 더 넣어야 합니다.

- **다익스트라 알고리즘: 간단한 구현 방법**
  - 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 **매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)** 합니다.

  ```python
  import sys
  input = sys.stdin.readline
  INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정
  
  # 노드의 개수, 간선의 개수를 입력받기
  n, m = map(int, input().split())
  # 시작 노드 번호를 입력받기
  start = int(input())
  # 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
  graph = [[] for i in range(n + 1)]
  # 방문한 적이 있는지 체크하는 목적의 리스트를 만들기
  visited = [False] * (n + 1)
  # 최단 거리 테이블을 모두 무한으로 초기화
  distance = [INF] * (n + 1)
  
  # 모든 간선 정보를 입력받기
  for _ in range(m):
      a, b, c = map(int, input().split())
      # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
      graph[a].append((b, c))
  
  # 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
  def get_smallest_node():
      min_value = INF
      index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
      for i in range(1, n + 1):
          if distance[i] < min_value and not visited[i]:
              min_value = distance[i]
              index = i
      return index
  
  def dijkstra(start):
      # 시작 노드에 대해서 초기화
      distance[start] = 0
      visited[start] = True
      for j in graph[start]:
          distance[j[0]] = j[1]
      # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
      for i in range(n - 1):
          # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
          now = get_smallest_node()
          visited[now] = True
          # 현재 노드와 연결된 다른 노드를 확인
          for j in graph[now]:
              cost = distance[now] + j[1]
              # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
              if cost < distance[j[0]]:
                  distance[j[0]] = cost
  
  # 다익스트라 알고리즘을 수행
  dijkstra(start)
  
  # 모든 노드로 가기 위한 최단 거리를 출력
  for i in range(1, n + 1):
      # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
      if distance[i] == INF:
          print("INFINITY")
      # 도달할 수 있는 경우 거리를 출력
      else:
          print(distance[i])
  ```

- **다익스트라 알고리즘: 간단한 구현 방법 성능 분석**
  - 총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 합니다.
    - V: 전체 노드의 개수
  - 따라서 전체 시간 복잡도는 O(V<sup>2</sup>)입니다.
  - 일반적으로 코딩 테스트의 최단 경로 문제에서 전체 노드의 개수가 5,000개 이하라면 이 코드로 문제를 해결할 수 있스빈다.
    - 하지만 노드의 개수가 10,000개를 넘어가는 문제라면 어떻게 해야 할까요?

#### 우선순위 큐(Priority Queue)

- <u>우선순위가 가장 높은 데이터를 가장 먼저 삭제</u>하는 자료구조입니다.
- 예를 들어 여러개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우에 우선순위 큐를 이용할 수 있습니다.
- Python, C++, Java를 포함한 대부분의 프로그래밍 언어에서 **표준 라이브러리 형태로 지원**합니다.

| 자료구조                    | 추출되는 데이터             |
| --------------------------- | --------------------------- |
| 스택(Stack)                 | 가장 나중에 삽입된 데이터   |
| 큐(Queue)                   | 가장 먼저 삽입된 데이터     |
| 우선순위 큐(Priority Queue) | 가장 우선순위가 높은 데이터 |

#### 힙(Heap)

- <u>우선순위 큐(Priority Queue)를 구현하기 위해 사용하는 자료구조 중 하나</u>입니다.
- **최소 힙(Min Heap)**과 **최대 힙(Max Heap)**이 있습니다.
- 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 사용됩니다.

| 우선순위 큐 구현방식 | 삽입 시간 | 삭제 시간 |
| -------------------- | --------- | --------- |
| 리스트               | O(1)      | O(N)      |
| 힙(Heap)             | O(logN)   | O(logN)   |

- **힙 라이브러리 사용 예제: 최소 힙**

  ```python
  import heapq
  
  # 오름차순 힙 정렬(Heap Sort)
  def heapsort(iterable):
      h = []
      result = []
      # 모든 원소를 차례대로 힙에 삽입
      for value in iterable:
          heapq.heappush(h, value)
      # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
      for i in range(len(h)):
          result.append(heapq.heappop(h))
      
      return result
  
  result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
  print(result)
  ```

- **힙 라이브러리 사용 예제: 최대 힙**

  ```python
  import heapq
  
  # 내림차순 힙 정렬(Heap Sort)
  def heapsort(iterable):
      h = []
      result = []
      # 모든 원소를 차례대로 힙에 삽입
      for value in iterable:
          heapq.heappush(h, -value)
      # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
      for i in range(len(h)):
          result.append(-heapq.heappop(h))
      
  ```

#### 다익스트라 알고리즘: 개선된 구현 방법

- 단계마다 <u>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택</u>하기 위해 **힙(Heap)** 자료구조를 이용합니다.

- 다익스트라 알고리즘이 동작하는 **기본 원리는 동일**합니다.

  - 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다릅니다.
  - 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용합니다. 

- **다익스트라 알고리즘: 동작 과정 살펴보기 (우선순위 큐)**

  - **[초기 상태]** 그래프를 준비하고 출발 노드를 설정하여 우선순위 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020030510982.png" alt="image-20201020030510982" style="zoom:67%;" />

  - **[Step 1]** 우선순위 큐에서 원소를 꺼냅니다. **1번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020030844243.png" alt="image-20201020030844243" style="zoom:67%;" />

  - **[Step 2]** 우선순위 큐에서 원소를 꺼냅니다. **4번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020031010043.png" alt="image-20201020031010043" style="zoom:67%;" />

  - **[Step 3]** 우선순위 큐에서 원소를 꺼냅니다. **2번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020031143042.png" alt="image-20201020031143042" style="zoom:67%;" />

  - **[Step 4]** 우선순위 큐에서 원소를 꺼냅니다. **5번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020031303368.png" alt="image-20201020031303368" style="zoom:67%;" />

  - **[Step 5]** 우선순위 큐에서 원소를 꺼냅니다. **3번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020031339374.png" alt="image-20201020031339374" style="zoom:67%;" />

  - **[Step 6]** 우선순위 큐에서 원소를 꺼냅니다. **3번** 노드는 이미 방문했으므로 무시합니다.

    - 별도로 방문 여부를 기록하는 하나의 테이블을 사용하지 않고, 단순히 최단 거리 테이블과 비교해서 <u>현재 거리 값보다 크면</u> 해당 노드를 무시하게 구현

  - **[Step 7]** 우선순위 큐에서 원소를 꺼냅니다. **6번** 노드는 아직 방문하지 않았으므로 이를 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020031615356.png" alt="image-20201020031615356" style="zoom:67%;" />

  - **[Step 8]** 우선순위 큐에서 원소를 꺼냅니다. **3번** 노드는 이미 방문했으므로 무시합니다.
  
- **다익스트라 알고리즘: 개선된 구현 방법 (Python)**
- **다익스트라 알고리즘: 개선된 구현 방법 성능 분석**
  - 힙 자료구조를 이용하는 다익스트라 알고리즘의 시간 복잡도는 O(ElogV)입니다.
  - 노드를 하나씩 꺼내 검사하는 반복문(while문)은 노드의 개수 V 이상의 횟수로는 처리되지 않습니다.
    - 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 간선의 개수(E)만큼 연산이 수행될 수 있습니다.
  - 직관적으로 <u>전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사</u>합니다.
    - 시간 복잡도 O(ElogE)로 판단할 수 있습니다.
    - 중복 간선을 포함하지 않는 경우에 이를 O(ElogV)로 정리할 수 있습니다.
      -  O(ElogE) → O(ElogV<sup>2</sup>) → O(2ElogV) → O(ElogV)

#### 플로이드 워셜 알고리즘

- **플로이드 워셜 알고리즘 개요**

  - <u>모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산</u>합니다. 
  - 플로이드 워셜(Floyd-Warshall) 알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 **거쳐 가는 노드를 기준으로 알고리즘을 수행**합니다.
    - 다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않습니다.
  - 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장합니다.
  - 플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속합니다.

- **플로이드 워셜 알고리즘**

  - 각 단계마다 특정한 노드 k를 거쳐 가는 경우를 확인합니다.

    - a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사합니다.

  - 점화식은 다음과 같습니다.
    $$
    D_{ab} =  min(D_{ab}, D_{ak} + D_{kb})
    $$

- **플로이드 워셜 알고리즘: 동작 과정 살펴보기**

  - **[초기 상태]** 그래프를 준비하고 최단 거리 테이블을 초기화합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020112403045.png" alt="image-20201020112403045" style="zoom:67%;" />

  - **[Step 1]** **1번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020112458810.png" alt="image-20201020112458810" style="zoom:67%;" />

  - **[Step 2]** **2번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020112546593.png" alt="image-20201020112546593" style="zoom:67%;" />

  - **[Step 3]** **3번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020112634044.png" alt="image-20201020112634044" style="zoom:67%;" />

  - **[Step 4]** **4번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020112708334.png" alt="image-20201020112708334" style="zoom:67%;" />

- **플로이드 워셜 알고리즘**

  ```python
  INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정
  
  # 노드의 개수 및 간선의 개수를 입력받기
  n = int(input())
  m = int(input())
  # 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
  graph = [[INF] * (n + 1) for _ in range(n + 1)]
  
  # 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          if a == b:
              graph[a][b] = 0
  
  # 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
  for _ in range(m):
      # A에서 B로 가는 비용은 C라고 설정
      a, b, c = map(int, input().split())
      graph[a][b] = c
  
  # 점화식에 따라 플로이드 워셜 알고리즘을 수행
  for k in range(1, n + 1):
      for a in range(1, n + 1):
          for b in range(1, n + 1):
              graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
  
  # 수행된 결과를 출력
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
          if graph[a][b] == 1e9:
              print("INFINITY", end=" ")
          # 도달할 수 있는 경우 거리를 출력
          else:
              print(graph[a][b], end=" ")
      print()
  ```

- **플로이드 워셜 알고리즘 성능 분석**
  - 노드의 개수가 N개일 때 알고리즘상으로 N번의 단계를 수행합니다.
    - 각 단계마다 O(N<sup>2</sup>)의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려합니다.
  - 따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 O(N<sup>3</sup>)입니다.



## 기타 그래프 알고리즘

#### 서로소 집합

- 서로소 집합(Disjoint Sets)란 <u>공통 원소가 없는 두 집합</u>을 의미합니다.
  - {1,2}와 {3,4}는 서로소 관계이다.
  - {1,2}와 {2,3}은 서로소 관계가 아니다.

#### 서로소 집합 자료구조

- <u>서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</u>입니다.

- 서로소 집합 자료구조는 두 종류의 연산을 지원합니다.

  - **합집합(Union)**: 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산입니다.
  - **찾기(Find)**: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산입니다.

- 서로소 집합 자료구조는 **합치기 찾기(Union Find) 자료구조**라고 불리기도 합니다.

- 여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작 과정은 다음과 같습니다.

  1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인합니다.

     1) A와 B의 루트 노드 A<sup>'</sup>,  B<sup>'</sup>를 각각 찾습니다.

     2) A<sup>'</sup>를  B<sup>'</sup>의 부모 노드로 설정합니다.

  2. 모든 합집합(Union) 연산을 처리할 때까지 1번의 과정을 반복합니다.

- **서로소 집합 자료구조: 동작 과정 살펴보기**

  - **처리할 연산들**: Union(1,4), Union(2,3), Union(2,4), Union(5,6)
  - **[초기 단계]** 노드의 개수 크기와 부모 테이블을 초기화합니다.
    - 집합에 자기 자신 밖에 없기 때문에, 부모 노드를 자기 자신으로 초기화

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020120600450.png" alt="image-20201020120600450" style="zoom:67%;" />

  - **처리할 연산들**: **Union(1,4)**, Union(2,3), Union(2,4), Union(5,6)
  - **[Step 1]** 노드 1과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 1과 4이므로 더 큰 번호에 해당하는 루트 노드 4의 부모를 1로 설정합니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020120810417.png" alt="image-20201020120810417" style="zoom:67%;" />

  - **처리할 연산들**: **Union(1,4), Union(2,3)**, Union(2,4), Union(5,6)
  - **[Step 1]** 노드 2과 노드 3의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 3이므로 더 큰 번호에 해당하는 루트 노드 3의 부모를 2로 설정합니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020121006721.png" alt="image-20201020121006721" style="zoom:67%;" />

  - **처리할 연산들**: **Union(1,4), Union(2,3), Union(2,4)**, Union(5,6)
  - **[Step 2]** 노드 2과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 1이므로 더 큰 번호에 해당하는 루트 노드 2의 부모를 1로 설정합니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020121103327.png" alt="image-20201020121103327" style="zoom:67%;" />

  - **처리할 연산들**: **Union(1,4), Union(2,3), Union(2,4), Union(5,6)**
  - **[Step 2]** 노드 5과 노드 6의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 5와 6이므로 더 큰 번호에 해당하는 루트 노드 6의 부모를 5로 설정합니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020121220844.png" alt="image-20201020121220844" style="zoom:67%;" />

- **서로소 집합 자료구조: 연결성**

  - 서로소 집합 자료구조에서는 **연결성**을 통해 손쉽게 집합의 형태를 확인할 수 있습니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020121322716.png" alt="image-20201020121322716" style="zoom: 67%;" />

  - 기본적인 형태의 서로소 집합 자료구조에서는 루트 노드에 즉시 접근할 수 없습니다.

    - 루트 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 합니다.

  - 다음 예시에서 노드 3의 루트를 찾기 위해서는 노드 2를 거쳐 노드 1에 접근해야 합니다.

- **서로소 집합 자료구조: 기본적인 구현 방법 (Python)**

  ```python
  # 특정 원소가 속한 집합을 찾기
  def find_parent(parent, x):
      # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
      if parent[x] != x:
          return find_parent(parent, parent[x])
      return x
  
  # 두 원소가 속한 집합을 합치기
  def union_parent(parent, a, b):
      a = find_parent(parent, a)
      b = find_parent(parent, b)
      if a < b:
          parent[b] = a
      else:
          parent[a] = b
  
  # 노드의 개수와 간선(Union 연산)의 개수 입력 받기
  v, e = map(int, input().split())
  parent = [0] * (v + 1) # 부모 테이블 초기화하기
  
  # 부모 테이블상에서, 부모를 자기 자신으로 초기화
  for i in range(1, v + 1):
      parent[i] = i
  
  # Union 연산을 각각 수행
  for i in range(e):
      a, b = map(int, input().split())
      union_parent(parent, a, b)
  
  # 각 원소가 속한 집합 출력하기
  print('각 원소가 속한 집합: ', end='')
  for i in range(1, v + 1):
      print(find_parent(parent, i), end=' ')
  
  print()
  
  # 부모 테이블 내용 출력하기
  print('부모 테이블: ', end='')
  for i in range(1, v + 1):
      print(parent[i], end=' ')
  ```

- **서로소 집합 자료구조: 기본적인 구현 방법의 문제점**

  - 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율적으로 동작합니다.

  - 최악의 경우에는 찾기(Find) 함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 O(V)입니다.

    - 다음과 같이 {1,2,3,4,5}의 총 5개의 원소가 존재하는 상황을 확인해 봅시다.

    - **수행된 연산들**: Union(4,5), Union(3,4), Union(2,3), Union(1,2)

      <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020133504479.png" alt="image-20201020133504479" style="zoom:67%;" />

- **서로소 집합 자료구조: 경로 압축**

  - 찾기(Find) 함수를 최적화하기 위한 방법으로 경로 압축(Path Compression)을 이용할 수 있습니다.

    - 찾기(Find) 함수를 재귀적으로 호출한 뒤에 <u>부모 테이블 값을 바로 갱신</u>합니다.

      ```python
      # 특정 원소가 속한 집합을 찾기
      def find_parent(parent, x):
          # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
          if parent[x] != x:
              parent[x] = find_parent(parent, parent[x])
              
          return parent[x]
      ```

  - 경로 압축 기법을 적용하면 각 노드에 대하여 <u>찾기(Find) 함수를 호출한 이후에</u> 해당 노드의 루트 노드가 바로 부모 노드가 됩니다.

  - 동일한 예시에 대해서 **모든 합집합(Union) 함수를 처리한 후 각 원소에 대하여 찾기(Find) 함수를 수행하면 다음과 같이 부모 테이블이 갱신**됩니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020134000401.png" alt="image-20201020134000401" style="zoom:67%;" />

  - 기본적인 방법에 비하여 시간 복잡도가 개선됩니다.

  ```python
  # 특정 원소가 속한 집합을 찾기
  def find_parent(parent, x):
      # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
      if parent[x] != x:
          parent[x] = find_parent(parent, parent[x])
      return parent[x]
  
  # 두 원소가 속한 집합을 합치기
  def union_parent(parent, a, b):
      a = find_parent(parent, a)
      b = find_parent(parent, b)
      if a < b:
          parent[b] = a
      else:
          parent[a] = b
  
  # 노드의 개수와 간선(Union 연산)의 개수 입력 받기
  v, e = map(int, input().split())
  parent = [0] * (v + 1) # 부모 테이블 초기화하기
  
  # 부모 테이블상에서, 부모를 자기 자신으로 초기화
  for i in range(1, v + 1):
      parent[i] = i
  
  # Union 연산을 각각 수행
  for i in range(e):
      a, b = map(int, input().split())
      union_parent(parent, a, b)
  
  # 각 원소가 속한 집합 출력하기
  print('각 원소가 속한 집합: ', end='')
  for i in range(1, v + 1):
      print(find_parent(parent, i), end=' ')
  
  print()
  
  # 부모 테이블 내용 출력하기
  print('부모 테이블: ', end='')
  for i in range(1,
      print(parent[i], end=' ')
  ```

#### 서로소 집합을 활용한 사이클 판별

- 서로소 집합은 **무방향 그래프 내에서 사이클을 판별**할 때 사용할 수 있습니다.

  -  참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있습니다.

- **사이클 판별 알고리즘**은 다음과 같습니다.

  1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인합니다.

     1) 루트 노드가 서로 다르다면 두 노드에 대하여 합집합(Union) 연산을 수행합니다.

     2) 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것입니다.

  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복합니다.

- **서로소 집합을 활용한 사이클 판별: 동작 과정 살펴보기**

  - **[초기 단계]** 모든 노드에 대하여 자기 자신을 부모로 설정하는 형태로 부모 테이블을 초기화합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020134827740.png" alt="image-20201020134827740" style="zoom:67%;" />

  - **[Step 1]** 간선 (1,2)를 확인합니다. 노드 1과 노드 2의 루트 노드는 각각 1과 2입니다. 따라서 더 큰 번호에 해당하는 노드 2의 부모 노드를 1로 변경합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020135132512.png" alt="image-20201020135132512" style="zoom:67%;" />

  - **[Step 2]** 간선 (1,3)를 확인합니다. 노드 1과 노드 3의 루트 노드는 각각 1과 3입니다. 따라서 더 큰 번호에 해당하는 노드 3의 부모 노드를 1로 변경합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020135231321.png" alt="image-20201020135231321" style="zoom:67%;" />

  - **[Step 3]** 간선 (2,3)를 확인합니다. 이미 노드 2과 노드 3의 루트 노드는 모두 1입니다. 다시 말해 **사이클이 발생**한다는 것을 알 수 있습니다. 

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020135337493.png" alt="image-20201020135337493" style="zoom:67%;" />

- **서로소 집합을 활용한 사이클 판별**

  ```python
  # 특정 원소가 속한 집합을 찾기
  def find_parent(parent, x):
      # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
      if parent[x] != x:
          parent[x] = find_parent(parent, parent[x])
      return parent[x]
  
  # 두 원소가 속한 집합을 합치기
  def union_parent(parent, a, b):
      a = find_parent(parent, a)
      b = find_parent(parent, b)
      if a < b:
          parent[b] = a
      else:
          parent[a] = b
  
  # 노드의 개수와 간선(Union 연산)의 개수 입력 받기
  v, e = map(int, input().split())
  parent = [0] * (v + 1) # 부모 테이블 초기화하기
  
  # 부모 테이블상에서, 부모를 자기 자신으로 초기화
  for i in range(1, v + 1):
      parent[i] = i
  
  cycle = False # 사이클 발생 여부
  
  for i in range(e):
      a, b = map(int, input().split())
      # 사이클이 발생한 경우 종료
      if find_parent(parent, a) == find_parent(parent, b):
          cycle = True
          break
      # 사이클이 발생하지 않았다면 합집합(Union) 연산 수행
      else:
          union_parent(parent, a, b)
  
  if cycle:
      print("사이클이 발생했습니다.")
  else:
      print("사이클이 발생하지 않았습니다.")
  ```

#### 신장 트리

- <u>그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프</u>를 의미합니다.

  - 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 **트리**의 조건이기도 합니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020140243122.png" alt="image-20201020140243122" style="zoom:67%;" />

#### 최소 신장 트리

- <u>최소한의 비용으로 구성되는 신장 트리를 찾아야 할 때</u> 어떻게 해야 할까요?

- 예를 들어 N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 **전체 도시가 서로 연결**될 수 있게 도로를 설치하는 경우를 생각해 봅시다.

  - 두 도시 A,B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재하도록 도로를 설치합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020140711650.png" alt="image-20201020140711650" style="zoom:67%;" />

#### 크루스칼 알고리즘

- 대표적인 **최소 신장 트리 알고리즘**입니다.

- 그리디 알고리즘으로 분류됩니다.

- 구체적인 동작 과정은 다음과 같습니다.

  1. 간선 데이터를 비용에 따라 **오름차순으로 정렬**합니다.

  2. 간선을 하나씩 확인하며 <u>현재의 간선이 사이클을 발생시키는지 확인</u>합니다.

     1) 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킵니다.

     2) 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않습니다.

  3. 모든 간선에 대하여 2번의 과정을 반복합니다.
  
- **크루스칼 알고리즘: 동작 과정 살펴보기**

  - **[초기 단계]** 그래프의 모든 간선 정보에 대하여 **오름차순 정렬을 수행**합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020202619435.png" alt="image-20201020202619435" style="zoom:67%;" />

    - 최소 신장 트리의 간선의 개수 = 전체 노드의 개수 - 1

  - **[Step 1]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (3,4)를 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020202822380.png" alt="image-20201020202822380" style="zoom:67%;" />

  - **[Step 2]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (4,7)를 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020203026936.png" alt="image-20201020203026936" style="zoom:67%;" />

  - **[Step 3]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (4,6)을 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020203124197.png" alt="image-20201020203124197" style="zoom:67%;" />

  - **[Step 4]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (6,7)을 선택하여 처리합니다.

    - 6번 노드와 7번 노드는 이미 같은 간선에 포함되어 있기 때문에, 신장 트리에 포함시키지 않는다.

  - **[Step 5]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (1,2)를 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020203314588.png" alt="image-20201020203314588" style="zoom:67%;" />

  - **[Step 6]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (2,6)를 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020203615365.png" alt="image-20201020203615365" style="zoom:67%;" />

  - **[Step 7]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (2,3)를 선택하여 처리합니다.

    - 2번 노드와 3번 노드는 이미 같은 간선에 포함되어 있기 때문에, 신장 트리에 포함시키지 않는다.

  - **[Step 8]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (5,6)를 선택하여 처리합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020203738534.png" alt="image-20201020203738534" style="zoom:67%;" />

  - **[Step 9]** 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (1,5)를 선택하여 처리합니다.

    - 1번 노드와 5번 노드는 이미 같은 간선에 포함되어 있기 때문에, 신장 트리에 포함시키지 않는다.

  - **알고리즘 수행 결과**

    - 최소 신장 트리에 포함되어 있는 간선의 비용만 모두 더하면, 그 값이 최종 비용에 해당합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020204152942.png" alt="image-20201020204152942" style="zoom: 50%;" />

- **크루스칼 알고리즘 (Python)**

  ```python
  # 특정 원소가 속한 집합을 찾기
  def find_parent(parent, x):
      # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
      if parent[x] != x:
          parent[x] = find_parent(parent, parent[x])
      return parent[x]
  
  # 두 원소가 속한 집합을 합치기
  def union_parent(parent, a, b):
      a = find_parent(parent, a)
      b = find_parent(parent, b)
      if a < b:
          parent[b] = a
      else:
          parent[a] = b
  
  # 노드의 개수와 간선(Union 연산)의 개수 입력 받기
  v, e = map(int, input().split())
  parent = [0] * (v + 1) # 부모 테이블 초기화하기
  
  # 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
  edges = []
  result = 0
  
  # 부모 테이블상에서, 부모를 자기 자신으로 초기화
  for i in range(1, v + 1):
      parent[i] = i
  
  # 모든 간선에 대한 정보를 입력 받기
  for _ in range(e):
      a, b, cost = map(int, input().split())
      # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
      edges.append((cost, a, b))
  
  # 간선을 비용순으로 정렬
  edges.sort()
  
  # 간선을 하나씩 확인하며
  for edge in edges:
      cost, a, b = edge
      # 사이클이 발생하지 않는 경우에만 집합에 포함
      if find_parent(parent, a) != find_parent(parent, b):
          union_parent(parent, a, b)
          result += cost
  
  print(result)
  ```

- **크루스칼 알고리즘 성능 분석**
  - 크루스칼 알고리즘은 간선의 개수가 E개일 때, O(ElogE)의 시간 복잡도를 가집니다.
  - 크루스칼 알고리즘에서 가장 많은 시간을 요구하는 곳은 간선에 대해서 정렬을 수행하는 부분입니다.
    - 표준 라이브러리를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도는 O(ElogE)입니다.

#### 위상 정렬

- **사이클이 없는 방향 그래프**의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**하는 것을 의미합니다.

  - 예시)  선수 과목을 고려한 학습 순서 설정

- **진입차수와 진출차수**

  - **진입차수(Indegree)**: 특정한 노드로 들어오는 간선의 개수

  - **진출차수(Outdegree)**: 특정한 노드에서 나가는 간선의 개수

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020204746113.png" alt="image-20201020204746113" style="zoom: 50%;" />

- **위상 정렬 알고리즘**

  - **큐**를 이용하는 **위상 정렬 알고리즘의 동작 과정**은 다음과 같습니다.

    1. 진입차수가 0인 모든 노드를 큐에 넣는다.

    2. 큐가 빌 때까지 다음의 과정을 반복한다.

       1) 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다.

       2) 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

  - 결과적으로 **각 노드가 큐에 들어온 순서가 위상정렬을 수행한 결과**와 같습니다.

- **위상 정렬 동작 예시**

  - 위상 정렬을 수행할 그래프를 준비합니다.

    - 이때 그래프는 **사이클이 없는 방향 그래프 (DAG)**여야 합니다.

  - **[초기 단계]** 초기 단계에서는 **진입차수가 0인 모든 노드**를 큐에 넣습니다.

    - 처음에 노드 1이 큐에 삽입됩니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205238222.png" alt="image-20201020205238222" style="zoom:67%;" />

  - **[Step 1]** 큐에서 **노드 1**을 꺼낸 뒤에 **노드 1**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**들을 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205357540.png" alt="image-20201020205357540" style="zoom:67%;" />

    - 여러개의 노드가 한번에 큐에 들어갈 때는 어떤 순서든지 상관 없지만, 일반적으로 노드 번호가 낮은 번호가 우선적으로 들어간다.

  - **[Step 2]** 큐에서 **노드 2**을 꺼낸 뒤에 **노드 2**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**들을 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205538238.png" alt="image-20201020205538238" style="zoom:67%;" />

  - **[Step 3]** 큐에서 **노드 5**을 꺼낸 뒤에 **노드 5**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**들을 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205640279.png" alt="image-20201020205640279" style="zoom:67%;" />

  - **[Step 4]** 큐에서 **노드 3**을 꺼낸 뒤에 **노드 3**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**가 없으므로 그냥 넘어갑니다.

  - **[Step 5]** 큐에서 **노드 6**을 꺼낸 뒤에 **노드 6**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**들을 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205751491.png" alt="image-20201020205751491" style="zoom:67%;" />

  - **[Step 6]** 큐에서 **노드 4**을 꺼낸 뒤에 **노드 4**에서 나가는 간선을 제거합니다.

    - 새롭게 **진입차수가 0이 된 노드**들을 큐에 삽입합니다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020205823926.png" alt="image-20201020205823926" style="zoom:67%;" />

  - **[Step 7]** 큐에서 **노드 7**을 꺼낸 뒤에 **노드 7**에서 나가는 간선을 제거합니다.
    
    - 새롭게 **진입차수가 0이 된 노드**가 없으므로 그냥 넘어갑니다.

- **위상 정렬의 결과**

  - 큐에 삽입된 전체 노드 순서: 1→2→5→3→6→4→7

- **위상 정렬의 특징**
  - 위상 정렬은 DAG에 대해서만 수행할 수 있습니다.
    - **DAG(Direct Acyclic Graph)**: 순환하지 않는 방향 그래프
  - 위상 정렬에서는 **여러 가지 답이 존재**할 수 있습니다.
    - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면 여러 가지 답이 존재합니다.
  - **모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재**한다고 판단할 수 있습니다.
    - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못합니다.
  - 스택을 활용한 DFS를 이용해 위상 정렬을 수행할 수도 있습니다.

- **위상 정렬 알고리즘 (Python)**

  ```python
  from collections import deque
  
  # 노드의 개수와 간선의 개수를 입력 받기
  v, e = map(int, input().split())
  # 모든 노드에 대한 진입차수는 0으로 초기화
  indegree = [0] * (v + 1)
  # 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
  graph = [[] for i in range(v + 1)]
  
  # 방향 그래프의 모든 간선 정보를 입력 받기
  for _ in range(e):
      a, b = map(int, input().split())
      graph[a].append(b) # 정점 A에서 B로 이동 가능
      # 진입 차수를 1 증가
      indegree[b] += 1
  
  # 위상 정렬 함수
  def topology_sort():
      result = [] # 알고리즘 수행 결과를 담을 리스트
      q = deque() # 큐 기능을 위한 deque 라이브러리 사용
  
      # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
      for i in range(1, v + 1):
          if indegree[i] == 0:
              q.append(i)
  
      # 큐가 빌 때까지 반복
      while q:
          # 큐에서 원소 꺼내기
          now = q.popleft()
          result.append(now)
          # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
          for i in graph[now]:
              indegree[i] -= 1
              # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
              if indegree[i] == 0:
                  q.append(i)
  
      # 위상 정렬을 수행한 결과 출력
      for i in result:
          print(i, end=' ')
  
  topology_sort()
  ```

- **위상 정렬 알고리즘 성능 분석**
  - 위상 정렬을 위해 차례대로 모든 노드를 확인하며 각 노드에서 나가는 간선을 차례대로 제거해야 합니다.
    
    - 위상 정렬 알고리즘의 시간 복잡도는 O(V+E)입니다.
    
    

## 기타 빈출 알고리즘

#### 소수 판별 알고리즘

- **소수 (Prime Number)**
  -  소수란 <u>1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어쩔어지지 않는 자연수</u> 입니다.
    - 6은 1, 2, 3, 6으로 나누어떨어지므로 소수가 아닙니다.
    - 7은 1과 7을 제외하고는 나누어떨어지지 않으므로 소수입니다.
  - 코딩 테스트에서는 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제가 자주 출제 됩니다.

- **소수의 판별: 기본적인 알고리즘 성능 분석**

  - 2부터 X-1까지의 모든 자연수에 대하여 연산을 수행해야 합니다.
  - 모든 수를 하나씩 확인한다는 점에서 시간 복잡도는 O(X)입니다.

- **약수의 성질**

  - **모든 약수가 가운데 약수를 기준으로 곱셉 연산에 대해 대칭**을 이루는 것을 알 수 있습니다.
    - 예를 들어 16의 약수는 1,2, 4, 8, 16입니다.
    - 이때 2x8=16은 8x2=16과 대칭입니다.
  - 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 <u>가운데 약수(제곱근)까지만 확인</u>하면 됩니다.
    - 예를 들어 16이 2로 나누어떨어진다는 것을 8로도 나누어떨어진다는 것을 의미합니다.

- **소수의 판별: 개선된 알고리즘(Python)**

  ```python
  import math
  
  # 소수 판별 함수
  def is_prime_number(x):
      # 2부터 x의 제곱근까지의 모든 수를 확인하며
      for i in range(2, int(math.sqrt(x)) + 1):
          # x가 해당 수로 나누어떨어진다면
          if x % i == 0:
              return False # 소수가 아님
      return True # 소수임
  
  print(is_prime_number(4)) # 4는 소수가 아님
  print(is_prime_number(7)) # 7은 소수임
  ```

- **소수의 판별: 개선된 알고리즘 성능 분석**
  - 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대하여 연산을 수행해야 합니다.
  - 시간 복잡도는 O(N<sup>1/2</sup>)입니다.

#### 에라토스테네스의 체

- **다수의 소수 판별**
  - 하나의 수에 대해서 소수인지 아닌지 판별하는 방법을 알아보았습니다.
  - 하지만 <u>특정한 수의 범위 안에 존재하는 모든 소수</u>를 찾아야 할때는 어떻게 할까요?
    - **에라토스테네스의 체 알고리즘**을 사용할 수 있습니다.

- **에라토스테네스의 체 알고리즘**
  - <u>다수의 자연수에 대하여 소수 여부를 판별</u>할 때 사용하는 대표적인 알고리즘입니다.
  - 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있습니다.
  - 에라토스테네스의 체 알고리즘의 **구체적인 동작 과정**은 다음과 같습니다.
    1. 2부터 N까지의 모든 자연수를 나열한다.
    2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
    3. 남은 수 중에서 i의 배수를 모두 제거한다 (i는 제거하지 않는다.)
    4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.

- **에라토스테네스 체 알고리즘 동작 예시**

  - **[초기 단계]** 2부터 26까지의 모든 자연수를 나열합니다. (N=26)
  - **[Step 1]** 아직 처리하지 않은 가장 작은 수 2를 제외한 2의 배수는 모두 제거합니다.
  - **[Step 2]** 아직 처리하지 않은 가장 작은 수 3를 제외한 3의 배수는 모두 제거합니다.
  - **[Step 3]** 아직 처리하지 않은 가장 작은 수 5를 제외한 5의 배수는 모두 제거합니다.
  - **[Step 4]** 마찬가지의 과정을 반복했을 때 최종적인 결과는 다음과 같습니다.

- **에라토스테네스 체 알고리즘 (Python)**

  ```python
  import math
  
  n = 1000 # 2부터 1,000까지의 모든 수에 대하여 소수 판별
  array = [True for i in range(n + 1)] # 처음엔 모든 수가 소수(True)인 것으로 초기화
  
  # 에라토스테네스의 체 알고리즘 
  for i in range(2, int(math.sqrt(n)) + 1): # 2부터 n의 제곱근까지의 모든 수를 확인하며
      if array[i] == True: # i가 소수인 경우 (남은 수인 경우)
          # i를 제외한 i의 모든 배수를 지우기
          j = 2 
          while i * j <= n:
              array[i * j] = False
              j += 1
  
  # 모든 소수 출력
  for i in range(2, n + 1):
      if array[i]:
          print(i, end=' ')
  ```

- **에라토스테네스의 체 알고리즘 성능 분석**
  - 에라토스테네스의 체의 알고리즘의 시간 복잡도는 사실상 선형 시간에 가까울 정도로 매우 빠릅니다.
    - 시간 복잡도는 O(NlogNlogN)입니다.
  - 에라토스테네스의 체 알고리즘은 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용될 수 있습니다.
    - 하지만 각 자연수에 대한 소수 여부를 저장해야 하므로 **메모리가 많이 필요**합니다.
    - **10억**이 소수인지 아닌지 판별해야 할 때 에라토스테네스의 체를 사용할 수 있을까요?

#### 투 포인터

- **투 포인터 (Two Pointer)**

  - **투 포인터 알고리즘**은 <u>리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리</u>하는 알고리즘을 의미합니다.
  - 흔히 2, 3, 4, 5, 6, 7번 학생을 지목해야할 때 간단히 '2번부터 7번까지의 학생'이라고 부르곤 합니다.
  - 리스트에 담긴 데이터에 순차적으로 접근해야할 때는 **시작점**과 **끝점** 2개의 점으로 접근할 데이터의 범위를 표현할 수 있습니다.

-  **특정한 합을 가지는 부분 연속 수열 찾기: 문제 설명**

  - N개의 자연수로 구성된 수열이 있습니다.
  - **합이 M인 부분 연속 수열의 개수**를 구해보세요.
  - 수행 시간 제한은 **O(N)**입니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021121903639.png" alt="image-20201021121903639" style="zoom:67%;" />

-  **특정한 합을 가지는 부분 연속 수열 찾기: 문제 해결 아이디어**

  - <u>투 포인터를 활용</u>하여 다음과 같은 **알고리즘**으로 문제를 해결할 수 있습니다.

    1. 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가리키도록 한다.
    2. 현재 부분 합이 M과 같다면, 카운트한다.
    3. 현재 부분 합이 M보다 작다면, end를 1 증가시킨다.
    4. 현재 부분 합이 M보다 크거나 같다면, start를 1 증가시킨다.
    5. 모든 경우를 확인할 때까지 2번부터 4번까지의 과정을 반복한다.

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021122512703.png" alt="image-20201021122512703" style="zoom:67%;" />

  - **M = 5**

  - **[초기 단계]** 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 합니다.

    - 현재의 부분합은 1이므로 무시합니다.
    - 현재 카운트: 0

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021122641113.png" alt="image-20201021122641113" style="zoom:67%;" />

  - **[Step 1]** 이전 단계에서의 부분합이 1이었기 때문에 end를 1 증가시킵니다.

    - 현재의 부분합은 3이므로 무시합니다.
    - 현재 카운트: 0

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021122801810.png" alt="image-20201021122801810" style="zoom:67%;" />

  - **[Step 2]** 이전 단계에서의 부분합이 3이었기 때문에 end를 1 증가시킵니다.

    - 현재의 부분합은 6이므로 무시합니다.
    - 현재 카운트: 0

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021122850453.png" alt="image-20201021122850453" style="zoom:67%;" />

  - **[Step 3]** 이전 단계에서의 부분합이 6이었기 때문에 start를 1 증가시킵니다.

    - 현재의 부분합은 5이므로 무시합니다.
    - 현재 카운트: 1

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021122952072.png" alt="image-20201021122952072" style="zoom:67%;" />

  - **[Step 4]** 이전 단계에서의 부분합이 5이었기 때문에 start를 1 증가시킵니다.

    - 현재의 부분합은 3이므로 무시합니다.
    - 현재 카운트: 1

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021123018405.png" alt="image-20201021123018405" style="zoom:67%;" />

  - **[Step 5]** 이전 단계에서의 부분합이 3이었기 때문에 end를 1 증가시킵니다.

    - 현재의 부분합은 5이므로 카운트를 증가시킵니다.
    - 현재 카운트: 2

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021123114262.png" alt="image-20201021123114262" style="zoom:67%;" />

  - **[Step 6]** 이전 단계에서의 부분합이 5이었기 때문에 start를 1 증가시킵니다.

    - 현재의 부분합은 2이므로 무시합니다.
    - 현재 카운트: 2

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021123356751.png" alt="image-20201021123356751" style="zoom:67%;" />

  - **[Step 7]** 이전 단계에서의 부분합이 2이었기 때문에 end를 1 증가시킵니다.

    - 현재의 부분합은 7이므로 무시합니다.
    - 현재 카운트: 2

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021123446253.png" alt="image-20201021123446253" style="zoom: 67%;" />

  - **[Step 8]** 이전 단계에서의 부분합이 7이었기 때문에 start를 1 증가시킵니다.

    - 현재의 부분합은 5이므로 카운트를 증가시킵니다.
    - 현재 카운트: 3

    <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021123554464.png" alt="image-20201021123554464" style="zoom:67%;" />

- **특정한 합을 가지는 부분 연속 수열 찾기: 코드 예시 (Python)**

  ```python
  n = 5 # 데이터의 개수 N
  m = 5 # 찾고자 하는 부분합 M
  data = [1, 2, 3, 2, 5] # 전체 수열
  
  count = 0
  interval_sum = 0
  end = 0
  
  # start를 차례대로 증가시키며 반복
  for start in range(n):
      # end를 가능한 만큼 이동시키기
      while interval_sum < m and end < n:
          interval_sum += data[end]
          end += 1
      # 부분합이 m일 때 카운트 증가
      if interval_sum == m:
          count += 1
      interval_sum -= data[start]
  
  print(count)
  ```

#### 구간 합 빠르게 계산하기

- **구간 합 (Interval Sum)**
  - **구간 합 문제**: 연속적으로 나열된 N개의 수가 있을 때 <u>특정 구간의 모든 수를 합한 값을 계산하는 문제</u>
  - 예를 들어 5개의 데이터로 구성된 수열 {10, 20, 30, 40, 50}이 있다고 가정합시다.
    - 두 번째 수부터 네 번째 수까지의 합은 20+30+40=90입니다.
- **구간 합 빠르게 계산하기: 문제 설명**
  - N개의 정수로 구성된 수열이 있습니다.
  - M개의 쿼리(Query) 정보가 주어집니다.
    - 각 쿼리는 Left와 Right으로 구성됩니다.
    - 각 쿼리에 대하여 [Left, Right] 구간에 포함된 데이터들의 합을 출력해야 합니다.
  - 수행 시간 제한은 **O(N + M)**입니다.

- **구간 합 빠르게 계산하기: 문제 해결 아이디어**

  - **접두사 합(Prefix Sum)**: 배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것
  - 접두사 합을 활용한 **알고리즘**은 다음과 같습니다.
    - N개의 수 위치 각각에 대하여 접두사 합을 계산하여 P에 저장합니다.
    - 매 M개의 쿼리 정보를 확일할 때 구간 합은 P[Right] - P[Left-1]입니다.

  <img src="C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201021124627354.png" alt="image-20201021124627354" style="zoom:67%;" />

- **구간 합 빠르게 계산하기: 코드 예시 (Python)**

  ```python
  # 데이터의 개수 N과 전체 데이터 선언
  n = 5
  data = [10, 20, 30, 40, 50]
  
  # 접두사 합(Prefix Sum) 배열 계산
  sum_value = 0
  prefix_sum = [0]
  for i in data:
      sum_value += i
      prefix_sum.append(sum_value)
  
  # 구간 합 계산 (세 번째 수부터 네 번째 수까지)
  left = 3
  right = 4
  print(prefix_sum[right] - prefix_sum[left - 1])
  ```
