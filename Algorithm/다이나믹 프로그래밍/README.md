# 다이나믹 프로그래밍 문제 

### 📝목차

- [1로 만들기](#1로-만들기)

- [개미 전사](#개미-전사)

- 바닥 공사

- [효율적인 화폐 구성](#효율적인-화폐-구성)

- [금광](#금광)

- [정수 삼각형](#https://www.acmicpc.net/problem/1932)

- [퇴사](#https://www.acmicpc.net/problem/14501)

- [병사 배치하기](#https://www.acmicpc.net/problem/18353)

- 못생긴 수

- 편집 거리

  

 ## 개미 전사

- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 합니다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있습니다.
- 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정입니다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있습니다.
- 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 <u>최소한 한 칸 이상 떨어진 식량창고를 약탈</u>해야 합니다.

![image-20201019214222976](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019214222976.png)

- 예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정합시다.

  ```
  {1, 3, 1, 5}
  ```

- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있습니다. 개미 전사는 식량 창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원합니다.

- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 **얻을 수 있는 식량의 최댓값**을 구사는 프로그램을 작성하세요.

**입력 조건**

- 첫째 줄에 식량창고의 개수 N이 주어집니다. (3 <= N <=100)
- 둘째 줄에 공백을 기준으로 각 식량창고에 저장된 식량의 개수 K가 주어집니다. (0 <= K <= 1,000)

**출력 조건**

- 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하세요.

| 입력 예시      | 출력 예시 |
| -------------- | --------- |
| 4<br />1 3 1 5 | 8         |

- **문제 해결 아이디어**

  - 예시를 확인해 봅시다. **N = 4**일 때, 다음과 같은 경우들이 존재할 수 있습니다.

    - 식량을 선택할 수 있는 경우의 수는 다음과 같이 8가지입니다.
    - 7번째 경우에서 8만큼의 식량을 얻을 수 있으므로 **최적의 해는 8**입니다.

    ![image-20201019214917902](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019214917902.png)

  - a<sub>i</sub>번째 식량창고까지의 최적의 해 (얻을 수 있는 식량의 최댓값)

    - 이렇게 정의한다면 다이나믹 프로그래밍을 적용할 수 있습니다.

    ![image-20201019215630801](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019215630801.png)

  - 왼쪽부터 차례대로 식량창고를 턴다고 했을 때, 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정하면, 아래 **2가지** 경우 중에서 더 많은 식량을 털 수 있는 경우를 선택하면 됩니다.

    ![image-20201019220152428](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019220152428.png)

  - a<sub>i</sub> =  i번째 식량창고까지의 최적의 해 (얻을 수 있는 식량의 최댓값)

  - k<sub>i</sub> = i번째 식량창고에 있는 식량의 양

  - 점화식은 다음과 같습니다.
    $$
    a_{i} =  max(a_{i-1}, a_{i-2} + k_{i})
    $$

  - 한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려할 필요가 없습니다.

## 1로 만들기

- 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 **4가지**입니다.
  1. X가 5로 나누어 떨어지면, 5로 나눕니다.
  2. X가 3으로 나누어 떨어지면, 3로 나눕니다.
  3. X가 2로 나누어 떨어지면, 2로 나눕니다.
  4. X에서 1을 뺍니다.
- 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 합니다. 연산을 사용하는 횟수의 최솟값을 출력하세요. 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값입니다.
  - 26 → 25 → 5 → 1

**입력 조건**

- 첫째 줄에 정수 X가 주어집니다. (1 <= X <= 30,000)

**출력 조건**

- 첫째 줄에 연산을 하는 횟수의 최솟값을 출력합니다.

| 입력 예시 | 출력 예시 |
| --------- | --------- |
| 26        | 3         |

- **문제 해결 아이디어**

  - 피보나치 수열  문제를 도식화한 것처럼 함수가 호출되는 과정을 그림으로 그려보면 다음과 같습니다.

    - **최적 부분 구조**와 **중복되는 부분 문제**를 만족합니다.
      ![image-20201019221235874](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019221235874.png)

  - a<sub>i</sub> = i를 1로 만들기 위한 최소 연산 횟수

  - 점화식은 다음과 같습니다.
    $$
    a_{i} = min(a_{i-1}, a_{i/2}, a_{i/2}, a_{i/5}) + 1
    $$

  - 단, 1을 연산을 제외하고는 <u>해당 수로 나누어 떨어질 때에 한해 점화식을 적용</u>할 수 있습니다.

## 효율적인 화폐 구성

- N가지 종류의 화폐가 있습니다. 이 화폐들의 개수를 최소한으로 이요해서 그 가치의 합이 M원이 되도록 하려고 합니다. 이때 각 종류의 화폐는 몇 개라도 사용할 수 있습니다.
- 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수입니다.
- <u>M원을 만들기 위한 최소한의 화폐 개수</u>를 출력하는 프로그램을 작성하세요.

**입력 조건**

- 첫째 줄에 N, M이 주어진다. (1 <= N <= 100, 1 <= M <= 10,000)
- 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수 이다.

**출력 조건**

- 첫째 줄에  최소 화폐 개수를 출력한다.
- 불가능할 때는 -1을 출력한다.

| 입력 예시                | 출력 예시 |
| ------------------------ | --------- |
| 2 15<br />2<br />3       | 5         |
| 3 4<br />3<br />5<br />7 | -1        |

- **문제 해결 아이디어**

  - a<sub>i</sub> = 금액 i를 만들 수 있는 최소한의 화폐 개수

  - k = 각 화폐의 단위

  - **점화식**: 각 화폐 단위인 k를 **하나씩 확인하며**

    - a<sub>i-k</sub>를 만드는 방법이 존재하는 경우, a<sub>i</sub> = min(a<sub>i</sub>, a<sub>i-k</sub>+1)
    - a<sub>i-k</sub>를 만드는 방법이 존재하지 않는 경우, a<sub>i</sub> = INF

  - N = 3, M = 7이고, 각 화폐의 단위가 2, 3, 5인 경우 확인해 봅시다.

    - **Step 0 (초기화)**

      - 먼저 각 인덱스에 해당하는 값으로 INF(무한)의 값을 설정합니다.
      - INF은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미를 가집니다.
      - 본 문제에서는 10, 001을 사용할 수 있습니다.

      ![image-20201019222353347](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201019222353347.png)
      
    - **Step 1**
    
      - 첫 번째 화폐 단위인 2를 확인합니다.
      - 점화식에 따라서 다음과 같이 리스트가 갱신됩니다.
    
      ![image-20201020010359863](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020010359863.png)
    
    - **Step 2**
    
      - 두 번째 화폐 단위인 3을 확인합니다.
      - 점화식에 따라서 다음과 같이 리스트가 갱신됩니다.
    
      ![image-20201020011401601](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020011401601.png)
    
    - **Step 3**
    
      - 세 번째 화폐 단위인 5를 확인합니다.
      - 점화식에 따라서 다음과 같이 최종적으로 리스트가 갱신됩니다.
    
      ![image-20201020011448383](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020011448383.png)

## 금광

- n x m 크기의 금광이 있습니다. 금광은 1 x 1크기의 칸으로 나누어져 있으며, 각 칸은 특정한 크기의 금이 들어 있습니다.
- 채굴자는 첫 번째 열부터 출발하여 금을 캐기 시작합니다. 맨 처음에는 첫 번째 열의 어느 행에서든 출발할 수 있습니다. 이후에 m - 1번에 걸쳐서 매번 오른쪽 위, 오른쪽, 오른쪽 아래 3가지 중 하나의 위치로 이동해야 합니다. 결과적으로 **채굴자가 얻을 수 있는 금의 최대 크기**를 출력하는 프로그램을 작성하세요.

![image-20201020011916453](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020011916453.png)

**입력 조건**

- 첫째 줄에 테스트 케이스 T가 입력됩니다. (1 <= T <= 1000)
- 매 테스트 케이스 첫째 줄에 n과 m이 공백으로 구분되어 입력됩니다. (1 <= n, m <= 20) 
- 둘째 줄에 n x m개의 위치에 매장된 금의 개수가 공백으로 구분되어 입력됩니다. (1 <= 각 위치에 매장된 금의 개수 <= 100)

**출력 조건**

- 테스트 케이스마다 채굴자가 얻을 수 있는 금의 최대 크기를 출력합니다. 각 테스트 케이스는 줄 바꿈을 이용해 구분합니다.

| **입력 예시**                                                | **출력 예시** |
| ------------------------------------------------------------ | ------------- |
| 2<br />3 4<br />1 3 3 2 2 1 4 1 0 6 4 7<br />4 4<br />1 3 1 5 2 2 4 1 5 0 2 3 0 6 1 2 | 19<br />16    |

- **문제 해결 아이디어**

  - 금광의 모든 위치에 대하여 다음의 세 가지만 고려하면 됩니다.

    1. 왼쪽 위에서 오는 경우
    2. 왼쪽 아래에서 오는 경우
    3. 왼쪽에서 오는 경우

  - **세 가지** 경우 중에서 <u>가장 많은 금을 가지고 있는 경우</u>를 테이블에 갱신해주어 문제를 해결합니다.

    ![image-20201020012949506](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020012949506.png)

  - `array[i][j]` = i 행 j열에 존재하는 금의 양

  - `dp[i][]j` =  i행 j열까지의 최적의 해 (얻을 수 있는 금의 최댓값)

  - 점화식은 다음과 같습니다.
    $$
    dp[i][j] = array[i][j] + max(dp[i-1][j-1], dp[i][j-1], dp[i+1][j-1])
    $$

  - 이때 테이블에 접근할 때마다 리스트의 범위를 벗어나지 않는지 체크해야 합니다.

  - 편의상 초기 데이터를 담는 변수 array를 사용하지 않아도 됩니다.

    - 바로 DP 테이블에 초기 데이터를 담에서 다이나믹 프로그래밍을 적용할 수 있습니다.

  ![image-20201020013315550](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020013315550.png)
- **정당성 분석**
  
  - N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있음
  - 다시 말해 K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음
    - 또한 N은 항상 1에 도달하게 됨 (최적의 해 성립)

## 병사 배치하기

- N명의 병사가 무작위로 나열되어 있습니다. 각 병사는 특정한 값의 전투력을 보유하고 있습니다.
- 병사를 배치할 때는 **전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치**를 하고자 합니다. 다시 말해 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 합니다.
- 또한 배치 과정에서는 특정한 위치에 있는 병사를 열외시키는 방법을 이용합니다. 그러면서도 남아 있는 병사의 수가 최대가 되도록 하고 싶습니다.
- 예를 들어, N = 7일때 나열된 병사들의 전투력이 다음과 같다고 가정하겠습니다.
  ![image-20201020013545510](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020013545510.png)
- 이때 3번 병사와 6번 병사를 열외시키면, 다음과 같이 남아 있는 병사의 수가 내림차순의 형태가 되며 5명이 됩니다. 이는 남아 있는 병사의 수가 최대가 되도록 하는 방법입니다.
  ![image-20201020013627573](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020013627573.png)

- 병사에 대한 정보가 주어졌을 때, 남아 있는 병사의 수가 최대가 되도록 하기 위해서 열외시켜야 하는 병사의 수를 출력하는 프로그램을 작성하세요.

**입력 조건**

- 첫째 줄에 N이 주어집니다. (1 <= N <= 2,000)

- 둘째 줄에 각 병사의 전투력이 공백으로 구분되어 차례대로 주어집니다. 각 병사의 전투력은 10,000,000보다 작거나 같은 자연수입니다.

**출력 조건**

- 첫째 줄에 남아 있는 병사의 수가 최대가 되도록 하기 위해서 열외시켜야 하는 병사의 수를 출력합니다.

| 입력 예시              | 출력 예시 |
| ---------------------- | --------- |
| 7<br />15 11 4 8 5 2 4 | 2         |

- **문제 해결 아이디어**

  - 이 문제의 기본 아이디어는 **가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS)**로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같습니다.
  
  - 예를 들어 하나의 수열 array = {4, 2, 5, 8, 4, 11, 15}이 있다고 합시다.
  
    - 이 수열의 가장 긴 증가하는 부분 수열은 {4, 5, 8, 11, 15}입니다.
  
  - <u>본 문제는 가장 긴 감소하는 부분 수열을 찾는 문제</u>로 치환할 수 있으므로, LIS 알고리즘을 조금 수정하여 적용함으로써 정답을 도출할 수 있습니다.
  
  - 가장 긴 증가하는 부분 수열 (LIS) 알고리즘을 확인해 봅시다.
  
    - D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
  
    - 점화식은 다음과 같습니다.
      $$
      모든  0<=j<i에 대하여,  D[i] = max(D[i], D[j] + 1)  if array[j] < array[i]
      $$
      ![image-20201020014749640](C:\Users\ann\AppData\Roaming\Typora\typora-user-images\image-20201020014749640.png)
  
  - 가장 먼저 입력 받은 병사 정보의 순서를 뒤집습니다.
  
  - **가장 긴 증가하는 부분 수열 (LIS)** 알고리즘을 수행하여 정답을 도출합니다.

