# 그리디 문제 

### 📝목차

- [거스름돈](#거스름돈)

- [동빈이의 큰 수의 법칙](#동빈이의-큰-수의-법칙)

- [숫자 카드 게임](#숫자-카드-게임)

- [1이 될 때까지](#1이-될-때까지)

- [모험가 길드](#모험가-길드)

- [곱하기 혹은 더하기](#곱하기-혹은-더하기)

- [문자열 뒤집기](https://www.acmicpc.net/problem/1439)

- [만들 수 없는 금액](#만들-수-없는-금액)

- [볼링공 고르기](#볼링공-고르기)

- [무지의 먹방 라이브]( https://programmers.co.kr/learn/courses/30/lessons/42891 )

  

 ## 거스름돈

당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수 입니다.

- **문제 해결 아이디어**
  - 최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 됨
  - N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 줌
    - 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면 됨
- **정당성 분석**
  - 가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문**
  - 만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500원, 400원, 100원이라면?
    - 500원이 400원의 배수가 아님
    - 최적의 해: 400원 x 2개
    - 알고리즘의 해: 500원 x 1개 + 100원 x 3개 

- **시간 복잡도 분석**
  - 화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 **O(K)**
  - 이 알고리즘의 시간 복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받음

## 동빈이의 큰 수의 법칙

동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 떄 주어진 수들을 M번 더하여
가장 큰 수를 만드는 방법이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여
더해 질수 없는 것이 이 법칙의 특징이다.

예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때, M이 8이고 K가 3이라고 가정하자
이 경우 특정한 인덱스의 수가 연속해서 세번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는
6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.

단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어
순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고 K가 2라고 가정하자.
이 경우 두번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두번씩 더하는 것이 가능하다. 결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를
제출하시오.

**입력 조건**
첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000)
의 자연수가 주어지며 각자연수는 공백으로 구분한다.
둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력 조건**
첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

## 숫자 카드게임

숫자 카드 게임은 여러개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.

1. 숫자가 쓰인 카드들이 N * M 형태로 놓여져 있다. 이 때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑는 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

**입력 조건**
첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다.
둘째 줄부터 N개의 줄에 걸쳐 각 카드가 적힌 숫자가 주어진다. 각 숫자는 1이상 10000 이하의 자연수 이다.

**출력조건**
첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

## 1이 될 때까지

어떠한 수 **N이 1이 될 때까지** 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.

1. N에서 1을 뺍니다.
2. N을 K로 나눕니다.

예를 들어 N이 17, K가 4라고 가정합시다. 이때 1번의 과정을 한 번 수행하면 N은 16이 됩니다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 됩니다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 됩니다. 이는 N을 1로 만드는 최소 횟수입니다.

N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 **과정을 수행해야 하는 최소 횟수**를 구하는 프로그램을 작성하세요. 

**입력 조건**

첫째 줄에 N(1 <= N <= 100,000)과 K(2 <= K <= 100,000)가 공백을 기준으로 하여 각각 자연수로 주어집니다.

**출력 조건**

첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 수행해야 하는 횟수의 최솟값을 출력합니다.

| **입력 예시** | **출력 예시** |
| ------------- | ------------- |
| 25 5          | 2             |

- **문제 해결 아이디어**
  - 주어진 N에 대하여 **최대한 많이 나누기**를 수행하면 됨
  - N의 값을 줄일 때 **2 이상의 수로 나눈 작업**이 **1을 빼는 작업보다** 수를 훨씬 많이 줄일 수 있음
- **정당성 분석**
  - N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있음
  - 다시 말해 K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음
    - 또한 N은 항상 1에 도달하게 됨 (최적의 해 성립)

## 모험가 길드

한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.

모험의 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 <u>공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여</u>해야 여행을 떠날 수 있도록 규정했습니다.

동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, **여행을 떠날 수 있는 그룹 수의 최댓값**을 구하는 프로그램을 작성하세요.

예를 들어 N = 5이고, 각 모험가의 공포도가 다음과 같다고 가정합시다.

```
2 3 1 2 2 
```

이 경우 그룹 1에 공포도가 1, 2, 3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두명을 넣게 되면 총 2개의 그룹을 만들 수 있습니다.

또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없습니다.

**입력 조건**

첫째 줄에 모험가의 수 N이 주어집니다. (1 <= N <= 100,000)

둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.

**출력 조건**

여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.

| 입력 예시        | 출력 예시 |
| ---------------- | --------- |
| 5<br />2 3 1 2 2 | 2         |

- **문제 해결 아이디어**

  - 오름차순 정렬 이후에 공포도가 가장 낮은 모험가부터 하나씩 확인
  - 앞에서부터 공포도를 하나씩 확인하며 **'현재 그룹에 포함된 모험가의 수'가 '현재 확인하고 있는 공포도'보다 크거나 같다면 이를 그룹으로 설정**
  - 이러한 방법을 이용하면 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성

## 곱하기 혹은 더하기

각 자리 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x'혹은 '+'연산자를 넣어 결과적으로 **만들어질 수 있는 가장 큰 수를 구하는 프로그램**을 작성하세요. 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, **모든 연산은 왼쪽에서부터 순서대로** 이루어진다고 가정합니다.

예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수 는 ((((0+2) x 9) x 8) x 4) = 576입니다. 또한 만들어질 수 있 는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.

**입력 조건**

첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다. (1 <= S의 길이 <= 20)

**출력 조건**

첫째 줄에서 만들어질 수 있는 가장 큰 수를 출력합니다.

| 입력 예시 | 출력 예시 |
| --------- | --------- |
| 02984     | 576       |
| 567       | 210       |

- **문제 해결 아이디어**
  - 대부분의 경우 '+'보다는 'x'가 더 값을 크게 만듦
  - 다만 두 수 중에서 하나라도 '0'혹은 '1'인 경우, 곱하기보다는 더하기가 효율적
  - 따라서 **두 수에 대하여 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하면, 두 수가 모두 2 이상인 경우에는 곱하면 정답**

## 만들 수 없는 금액

동네 편의점의 주인인 동빈이는 N개의 동전을 가지고 있습니다. 이때 N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램을 작성하세요.

예를 들어, N = 5이고, 각 동전이 각각 3원, 2원, 1원, 1원, 9원짜리(화폐단위)동전이라고 가정합시다. 이때 동빈이가 만들 수 없는 양의 정수 금액 중 최솟값은 8원 입니다.

또 다른 예시로, N = 3이고 각 동전이 각각 3원, 5원, 7원짜리 (화폐 단위) 동전이라고 가정합니다. 이떄 동빈이가 만들 수 없는 양의 정수 금액 중 최솟값을 1원 입니다.

| 입력 예시        | 출력 예시 |
| ---------------- | --------- |
| 5<br />3 2 1 1 9 | 8         |
| 3<br />3 5 7     | 1         |

## 볼링공 고르기

A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 골링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다.
또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주하빈다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다.

예를 들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1, 3, 2, 3, 2 일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다.

결과적으로 두 사람이 공을 고르는 경우의 수는 8가지 입니다. N개의 공의 무게가 각각주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요.

| 입력 예시                | 출력 예시 |
| ------------------------ | --------- |
| 5 3<br />1 3 2 3 2       | 8         |
| 8 5<br />1 5 4 3 2 4 5 2 | 25        |



